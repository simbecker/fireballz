<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Wizard Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 5px solid #4a90e2;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(74, 144, 226, 0.6), inset 0 0 20px rgba(74, 144, 226, 0.2);
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #0f1419;
            width: 100%;
            height: 100%;
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffffff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #instructions div {
            margin: 2px 0;
        }

        #connectionStatus {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        .connected {
            color: #4CAF50;
        }

        .disconnected {
            color: #f44336;
        }

        #playerCount {
            position: absolute;
            top: 40px;
            left: 10px;
            color: #ffffff;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #notifications {
            position: absolute;
            top: 70px;
            left: 10px;
            color: #ffffff;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            max-width: 200px;
        }

        #playerList {
            position: absolute;
            top: 110px;
            left: 10px;
            color: #ffffff;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            min-width: 150px;
        }

        .player-entry {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .player-entry.you {
            background: rgba(74, 144, 226, 0.3);
            border-left: 3px solid #4a90e2;
        }

        .player-entry.other {
            background: rgba(255, 107, 107, 0.3);
            border-left: 3px solid #ff6b6b;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="instructions">
            <div>üßô‚Äç‚ôÇÔ∏è WASD or Arrow Keys: Move</div>
            <div>üî• Spacebar: Shoot Fireball</div>
            <div>üéØ Mouse: Aim Direction</div>
            <div>‚ö° C: Teleport (cooldown)</div>
            <div>ü™ô Coins reduce teleport cooldown!</div>
            <div>ü§ñ Bot wizards compete for coins and attack you!</div>
            <div>üë• Multiplayer: See other players!</div>
        </div>
        <div id="connectionStatus" class="disconnected">
            Connecting...
        </div>
        <div id="playerCount">
            Players: 1
        </div>
        <div id="notifications">
            Waiting for players...
        </div>
        <div id="playerList">
            <div>Players on this map:</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const connectionStatusElement = document.getElementById('connectionStatus');
        const playerCountElement = document.getElementById('playerCount');
        const notificationsElement = document.getElementById('notifications');
        const playerListElement = document.getElementById('playerList');
        
        // Game world dimensions
        const WORLD_WIDTH = 3000;
        const WORLD_HEIGHT = 2250;
        
        // Zoom factor - higher = more zoomed in
        const ZOOM_FACTOR = 1.7;
        
        // Camera system
        const camera = {
            x: 0,
            y: 0,
            width: canvas.width / ZOOM_FACTOR,
            height: canvas.height / ZOOM_FACTOR,
            
            follow(target) {
                this.x = target.x - this.width / 2;
                this.y = target.y - this.height / 2;
                
                // Keep camera within world bounds
                this.x = Math.max(0, Math.min(this.x, WORLD_WIDTH - this.width));
                this.y = Math.max(0, Math.min(this.y, WORLD_HEIGHT - this.height));
            },
            
            updateSize() {
                this.width = canvas.width / ZOOM_FACTOR;
                this.height = canvas.height / ZOOM_FACTOR;
            }
        };
        
        // Set canvas to fullscreen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            camera.updateSize();
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game state
        let player = null;
        let otherPlayers = new Map();
        let fireballs = [];
        let coins = [];
        let bots = [];
        let teleportEffects = [];
        let playerId = null;
        let ws = null;
        
        // Input handling
        const keys = {};
        let mouseX = 0;
        let mouseY = 0;
        
        // WebSocket connection
        function connectToServer() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                connectionStatusElement.textContent = 'Connected';
                connectionStatusElement.className = 'connected';
                console.log('Connected to server');
            };
            
            ws.onclose = () => {
                connectionStatusElement.textContent = 'Disconnected';
                connectionStatusElement.className = 'disconnected';
                console.log('Disconnected from server');
                setTimeout(connectToServer, 3000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleServerMessage(data);
                } catch (error) {
                    console.error('Error parsing message:', error);
                }
            };
        }
        
        function handleServerMessage(data) {
            switch (data.type) {
                case 'init':
                    playerId = data.playerId;
                    player = data.players.find(p => p.id === playerId);
                    
                    // Add other players
                    data.players.forEach(p => {
                        if (p.id !== playerId) {
                            otherPlayers.set(p.id, p);
                        }
                    });
                    
                    coins = data.coins;
                    bots = data.bots;
                    updatePlayerCount();
                    console.log(`Initialized with ${data.players.length} players, ${coins.length} coins, ${bots.length} bots`);
                    break;
                    
                case 'playerJoined':
                    if (data.player.id !== playerId) {
                        otherPlayers.set(data.player.id, data.player);
                        updatePlayerCount();
                        showNotification(`Player joined! Total: ${otherPlayers.size + 1}`);
                    }
                    break;
                    
                case 'playerLeft':
                    otherPlayers.delete(data.playerId);
                    updatePlayerCount();
                    showNotification(`Player left! Total: ${otherPlayers.size + 1}`);
                    break;
                    
                case 'gameUpdate':
                    // Always clear and replace all state
                    otherPlayers.clear();
                    data.players.forEach(p => {
                        if (p.id === playerId) {
                            player = p;
                        } else {
                            otherPlayers.set(p.id, p);
                        }
                    });
                    fireballs = data.fireballs;
                    coins = data.coins;
                    bots = data.bots;
                    updatePlayerCount();
                    updatePlayerList();
                    console.log(`Game update: ${data.players.length} players, ${coins.length} coins, ${bots.length} bots, ${fireballs.length} fireballs`);
                    break;
                    
                case 'fireballShot':
                    fireballs.push(data.fireball);
                    break;
                    
                case 'playerTeleported':
                    if (data.playerId !== playerId && otherPlayers.has(data.playerId)) {
                        const otherPlayer = otherPlayers.get(data.playerId);
                        otherPlayer.x = data.x;
                        otherPlayer.y = data.y;
                    }
                    break;
                    
                case 'coinCollected':
                    if (data.playerId === playerId) {
                        // Update local player stats
                        player.coins = data.newCoins;
                        player.level = data.newLevel;
                    }
                    break;
            }
        }
        
        function updatePlayerCount() {
            playerCountElement.textContent = `Players: ${otherPlayers.size + 1}`;
            updatePlayerList();
        }
        
        function updatePlayerList() {
            if (!playerListElement) return;
            
            // Clear existing list
            playerListElement.innerHTML = '<div>Players on this map:</div>';
            
            // Add current player first
            if (player) {
                const playerEntry = document.createElement('div');
                playerEntry.className = 'player-entry you';
                playerEntry.textContent = `Player 1 (You) - Level ${player.level}`;
                playerListElement.appendChild(playerEntry);
            }
            
            // Add other players
            let playerNumber = 2;
            otherPlayers.forEach((otherPlayer, id) => {
                const playerEntry = document.createElement('div');
                playerEntry.className = 'player-entry other';
                playerEntry.textContent = `Player ${playerNumber} - Level ${otherPlayer.level || 1}`;
                playerListElement.appendChild(playerEntry);
                playerNumber++;
            });
        }
        
        function showNotification(message) {
            notificationsElement.textContent = message;
            setTimeout(() => {
                notificationsElement.textContent = '';
            }, 3000);
        }
        
        // Input event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === ' ') {
                e.preventDefault();
                shootFireball();
            }
            
            if (e.key.toLowerCase() === 'c') {
                e.preventDefault();
                teleport();
            }
            
            // Calculate direction for aiming
            let direction = 0;
            if (player) {
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                
                // Convert mouse screen coordinates to world coordinates
                const mouseWorldX = mouseX / ZOOM_FACTOR + camera.x;
                const mouseWorldY = mouseY / ZOOM_FACTOR + camera.y;
                
                // Calculate direction from player center to mouse world position
                direction = Math.atan2(mouseWorldY - centerY, mouseWorldX - centerX);
            }
            
            // Send input to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'updateInput',
                    keys: keys,
                    mouseX: mouseX,
                    mouseY: mouseY,
                    direction: direction
                }));
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            
            // Calculate direction for aiming
            let direction = 0;
            if (player) {
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                
                // Convert mouse screen coordinates to world coordinates
                const mouseWorldX = mouseX / ZOOM_FACTOR + camera.x;
                const mouseWorldY = mouseY / ZOOM_FACTOR + camera.y;
                
                // Calculate direction from player center to mouse world position
                direction = Math.atan2(mouseWorldY - centerY, mouseWorldX - centerX);
            }
            
            // Send input to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'updateInput',
                    keys: keys,
                    mouseX: mouseX,
                    mouseY: mouseY,
                    direction: direction
                }));
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            
            // Calculate direction for aiming
            let direction = 0;
            if (player) {
                const centerX = player.x + player.width / 2;
                const centerY = player.y + player.height / 2;
                
                // Convert mouse screen coordinates to world coordinates
                const mouseWorldX = mouseX / ZOOM_FACTOR + camera.x;
                const mouseWorldY = mouseY / ZOOM_FACTOR + camera.y;
                
                // Calculate direction from player center to mouse world position
                direction = Math.atan2(mouseWorldY - centerY, mouseWorldX - centerX);
            }
            
            // Send mouse position and direction to server
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'updateInput',
                    keys: keys,
                    mouseX: mouseX,
                    mouseY: mouseY,
                    direction: direction
                }));
            }
        });
        
        function shootFireball() {
            if (!player || !player.alive) return;
            
            const centerX = player.x + player.width / 2;
            const centerY = player.y + player.height / 2;
            
            // Convert mouse screen coordinates to world coordinates
            const mouseWorldX = mouseX / ZOOM_FACTOR + camera.x;
            const mouseWorldY = mouseY / ZOOM_FACTOR + camera.y;
            
            // Calculate direction from player center to mouse world position
            const direction = Math.atan2(mouseWorldY - centerY, mouseWorldX - centerX);
            
            // Create fireball at player center
            const fireballX = centerX;
            const fireballY = centerY;
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'shootFireball',
                    x: fireballX,
                    y: fireballY,
                    direction: direction,
                    size: player.fireballSize
                }));
            }
        }
        
        function teleport() {
            if (!player || !player.alive || player.teleportCooldown > 0) return;
            
            const teleportX = player.x + Math.cos(player.direction) * player.teleportDistance;
            const teleportY = player.y + Math.sin(player.direction) * player.teleportDistance;
            const newX = Math.max(0, Math.min(teleportX, WORLD_WIDTH - player.width));
            const newY = Math.max(0, Math.min(teleportY, WORLD_HEIGHT - player.height));
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'teleport',
                    x: newX,
                    y: newY
                }));
            }
        }
        
        // Drawing functions
        function drawWizard(wizard, isPlayer = false) {
            const screenX = (wizard.x - camera.x) * ZOOM_FACTOR;
            const screenY = (wizard.y - camera.y) * ZOOM_FACTOR;
            const scaleFactor = (1 + Math.log(wizard.level || 1) * 1.5) * ZOOM_FACTOR;
            
            ctx.save();
            ctx.translate(screenX + wizard.width/2 * ZOOM_FACTOR, screenY + wizard.height/2 * ZOOM_FACTOR);
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 20 * ZOOM_FACTOR, 18 * scaleFactor, 6 * scaleFactor, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Main body
            ctx.fillStyle = isPlayer ? '#4a0080' : wizard.color || '#ff6b6b';
            ctx.beginPath();
            ctx.arc(0, 0, 16 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            
            // Body outline
            ctx.strokeStyle = '#2a0050';
            ctx.lineWidth = 2 * scaleFactor;
            ctx.stroke();
            
            // Direction indicator
            ctx.fillStyle = isPlayer ? '#6a00b0' : wizard.color || '#ff6b6b';
            ctx.beginPath();
            ctx.ellipse(Math.cos(wizard.direction) * 6 * ZOOM_FACTOR, Math.sin(wizard.direction) * 6 * ZOOM_FACTOR, 8 * scaleFactor, 12 * scaleFactor, wizard.direction, 0, Math.PI * 2);
            ctx.fill();
            
            // Wizard hat
            ctx.fillStyle = '#1a0033';
            ctx.beginPath();
            ctx.moveTo(-8 * scaleFactor, -16 * scaleFactor);
            ctx.lineTo(8 * scaleFactor, -16 * scaleFactor);
            ctx.lineTo(0, -30 * scaleFactor);
            ctx.closePath();
            ctx.fill();
            
            // Hat outline
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1 * scaleFactor;
            ctx.stroke();
            
            // Hat star
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(0, -23 * scaleFactor, 2 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4 * scaleFactor, -5 * scaleFactor, 3 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4 * scaleFactor, -5 * scaleFactor, 3 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-4 * scaleFactor, -5 * scaleFactor, 1.5 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4 * scaleFactor, -5 * scaleFactor, 1.5 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            
            // Staff
            const staffLength = 25 * scaleFactor;
            const staffEndX = Math.cos(wizard.direction) * staffLength;
            const staffEndY = Math.sin(wizard.direction) * staffLength;
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 3 * scaleFactor;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(staffEndX, staffEndY);
            ctx.stroke();
            
            // Staff orb
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(staffEndX, staffEndY, 5 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            
            // Orb glow
            ctx.fillStyle = 'rgba(255, 107, 107, 0.4)';
            ctx.beginPath();
            ctx.arc(staffEndX, staffEndY, 8 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();
            
            // Directional arrow
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.moveTo(Math.cos(wizard.direction) * 10 * scaleFactor, Math.sin(wizard.direction) * 10 * scaleFactor);
            ctx.lineTo(Math.cos(wizard.direction + 2.5) * 6 * scaleFactor, Math.sin(wizard.direction + 2.5) * 6 * scaleFactor);
            ctx.lineTo(Math.cos(wizard.direction - 2.5) * 6 * scaleFactor, Math.sin(wizard.direction - 2.5) * 6 * scaleFactor);
            ctx.closePath();
            ctx.fill();
            
            // Player name for other players
            if (!isPlayer) {
                ctx.fillStyle = '#ffffff';
                ctx.font = (12 * ZOOM_FACTOR) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PLAYER', 0, -40 * scaleFactor);
                ctx.textAlign = 'left';
            }
            
            ctx.restore();
        }
        
        function drawFireball(fireball) {
            const screenX = (fireball.x - camera.x) * ZOOM_FACTOR;
            const screenY = (fireball.y - camera.y) * ZOOM_FACTOR;
            
            // Skip if off screen
            if (screenX < -50 * ZOOM_FACTOR || screenX > canvas.width + 50 * ZOOM_FACTOR || 
                screenY < -50 * ZOOM_FACTOR || screenY > canvas.height + 50 * ZOOM_FACTOR) return;
            
            ctx.save();
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(screenX, screenY, fireball.size * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner glow
            ctx.fillStyle = '#ff8844';
            ctx.beginPath();
            ctx.arc(screenX, screenY, fireball.size * 0.7 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Core
            ctx.fillStyle = '#ffff44';
            ctx.beginPath();
            ctx.arc(screenX, screenY, fireball.size * 0.4 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawCoin(coin) {
            if (coin.collected) return;
            
            const screenX = (coin.x - camera.x) * ZOOM_FACTOR;
            const screenY = (coin.y - camera.y) * ZOOM_FACTOR;
            
            // Skip if off screen
            if (screenX < -30 * ZOOM_FACTOR || screenX > canvas.width + 30 * ZOOM_FACTOR || 
                screenY < -30 * ZOOM_FACTOR || screenY > canvas.height + 30 * ZOOM_FACTOR) return;
            
            // Bob animation
            const bobY = screenY + Math.sin(Date.now() * 0.005 + coin.bobOffset) * 3 * ZOOM_FACTOR;
            
            // Coin shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(screenX, screenY + 15 * ZOOM_FACTOR, 8 * ZOOM_FACTOR, 3 * ZOOM_FACTOR, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Coin glow
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(screenX, bobY, coin.size * ZOOM_FACTOR + 5 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Main coin
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.arc(screenX, bobY, coin.size * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Coin outline
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 2 * ZOOM_FACTOR;
            ctx.stroke();
            
            // Inner circle
            ctx.fillStyle = '#ffed4e';
            ctx.beginPath();
            ctx.arc(screenX, bobY, coin.size * ZOOM_FACTOR - 3 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Coin symbol
            ctx.fillStyle = '#b8860b';
            ctx.save();
            ctx.translate(screenX, bobY);
            ctx.rotate(Date.now() * 0.001);
            
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5;
                const x = Math.cos(angle) * 4 * ZOOM_FACTOR;
                const y = Math.sin(angle) * 4 * ZOOM_FACTOR;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                const angle2 = ((i + 0.5) * Math.PI * 2) / 5;
                const x2 = Math.cos(angle2) * 2 * ZOOM_FACTOR;
                const y2 = Math.sin(angle2) * 2 * ZOOM_FACTOR;
                ctx.lineTo(x2, y2);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawBot(bot) {
            if (!bot.alive) return;
            
            const screenX = (bot.x - camera.x) * ZOOM_FACTOR;
            const screenY = (bot.y - camera.y) * ZOOM_FACTOR;
            
            // Skip if off screen
            if (screenX < -50 * ZOOM_FACTOR || screenX > canvas.width + 50 * ZOOM_FACTOR || 
                screenY < -50 * ZOOM_FACTOR || screenY > canvas.height + 50 * ZOOM_FACTOR) return;
            
            ctx.save();
            ctx.translate(screenX + bot.width/2 * ZOOM_FACTOR, screenY + bot.height/2 * ZOOM_FACTOR);
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 20 * ZOOM_FACTOR, 18 * ZOOM_FACTOR, 6 * ZOOM_FACTOR, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Main body
            ctx.fillStyle = bot.color || '#ff6b6b';
            ctx.beginPath();
            ctx.arc(0, 0, 16 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Body outline
            ctx.strokeStyle = '#2a0050';
            ctx.lineWidth = 2 * ZOOM_FACTOR;
            ctx.stroke();
            
            // Direction indicator
            ctx.fillStyle = bot.color || '#ff6b6b';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.ellipse(Math.cos(bot.direction) * 6 * ZOOM_FACTOR, Math.sin(bot.direction) * 6 * ZOOM_FACTOR, 8 * ZOOM_FACTOR, 12 * ZOOM_FACTOR, bot.direction, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // Wizard hat
            ctx.fillStyle = '#1a0033';
            ctx.beginPath();
            ctx.moveTo(-8 * ZOOM_FACTOR, -16 * ZOOM_FACTOR);
            ctx.lineTo(8 * ZOOM_FACTOR, -16 * ZOOM_FACTOR);
            ctx.lineTo(0, -30 * ZOOM_FACTOR);
            ctx.closePath();
            ctx.fill();
            
            // Hat outline
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1 * ZOOM_FACTOR;
            ctx.stroke();
            
            // Hat star
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(0, -23 * ZOOM_FACTOR, 2 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4 * ZOOM_FACTOR, -5 * ZOOM_FACTOR, 3 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4 * ZOOM_FACTOR, -5 * ZOOM_FACTOR, 3 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-4 * ZOOM_FACTOR, -5 * ZOOM_FACTOR, 1.5 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4 * ZOOM_FACTOR, -5 * ZOOM_FACTOR, 1.5 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Staff
            const staffLength = 25 * ZOOM_FACTOR;
            const staffEndX = Math.cos(bot.direction) * staffLength;
            const staffEndY = Math.sin(bot.direction) * staffLength;
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 3 * ZOOM_FACTOR;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(staffEndX, staffEndY);
            ctx.stroke();
            
            // Staff orb
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(staffEndX, staffEndY, 5 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Orb glow
            ctx.fillStyle = 'rgba(255, 107, 107, 0.4)';
            ctx.beginPath();
            ctx.arc(staffEndX, staffEndY, 8 * ZOOM_FACTOR, 0, Math.PI * 2);
            ctx.fill();
            
            // Directional arrow
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.moveTo(Math.cos(bot.direction) * 10 * ZOOM_FACTOR, Math.sin(bot.direction) * 10 * ZOOM_FACTOR);
            ctx.lineTo(Math.cos(bot.direction + 2.5) * 6 * ZOOM_FACTOR, Math.sin(bot.direction + 2.5) * 6 * ZOOM_FACTOR);
            ctx.lineTo(Math.cos(bot.direction - 2.5) * 6 * ZOOM_FACTOR, Math.sin(bot.direction - 2.5) * 6 * ZOOM_FACTOR);
            ctx.closePath();
            ctx.fill();
            
            // Bot indicator
            ctx.fillStyle = '#ff0000';
            ctx.font = (12 * ZOOM_FACTOR) + 'px Arial';
            ctx.fillText('BOT', -15 * ZOOM_FACTOR, -35 * ZOOM_FACTOR);
            
            ctx.restore();
        }
        
        function drawUI() {
            if (!player) return;
            
            // Level display
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 120, 30);
            ctx.fillStyle = '#fff';
            ctx.font = '18px Arial';
            ctx.fillText(`Level: ${player.level}`, 20, 30);
            
            // Health bar
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 50, 150, 35);
            ctx.fillStyle = '#ff0000';
            ctx.font = '16px Arial';
            ctx.fillText('‚ù§Ô∏è', 15, 70);
            ctx.fillStyle = '#fff';
            ctx.fillText(`Health: ${player.health}/${player.maxHealth}`, 40, 70);
            
            // Health bar background
            ctx.fillStyle = '#333';
            ctx.fillRect(15, 75, 120, 8);
            
            // Health bar fill
            const healthPercent = player.health / player.maxHealth;
            if (healthPercent > 0.5) {
                ctx.fillStyle = '#4ade80';
            } else if (healthPercent > 0.25) {
                ctx.fillStyle = '#fbbf24';
            } else {
                ctx.fillStyle = '#ef4444';
            }
            ctx.fillRect(15, 75, 120 * healthPercent, 8);
            
            // Coin counter
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 90, 120, 35);
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.fillText(`ü™ô Coins: ${player.coins}`, 20, 110);
            
            // Teleport cooldown
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 130, 150, 40);
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.fillText('Teleport (C)', 15, 150);
            
            const cooldownWidth = 120;
            const cooldownHeight = 8;
            const cooldownProgress = 1 - (player.teleportCooldown / player.teleportMaxCooldown);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(15, 155, cooldownWidth, cooldownHeight);
            
            if (player.teleportCooldown > 0) {
                ctx.fillStyle = '#ff6b6b';
            } else {
                ctx.fillStyle = '#4ade80';
            }
            ctx.fillRect(15, 155, cooldownWidth * cooldownProgress, cooldownHeight);
            
            if (player.teleportCooldown === 0) {
                ctx.fillStyle = '#4ade80';
                ctx.font = '14px Arial';
                ctx.fillText('READY!', 145, 162);
            }
        }
        
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ff0000';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '24px Arial';
            ctx.fillText(`Final Score: ${player.coins} coins`, canvas.width / 2, canvas.height / 2);
            ctx.fillText('Refresh to play again', canvas.width / 2, canvas.height / 2 + 50);
            
            ctx.textAlign = 'left';
        }
        
        function drawFrame() {
            // Draw a frame around the visible game area to show zoom boundaries
            ctx.strokeStyle = '#4a90e2';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
            ctx.setLineDash([]);
            
            // Add corner indicators
            ctx.fillStyle = '#4a90e2';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ZOOMED VIEW', canvas.width / 2, 25);
            ctx.textAlign = 'left';
        }
        
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw frame to show zoom boundaries
            drawFrame();
            
            if (player) {
                // Update camera to follow player
                camera.follow(player);
                
                // Draw coins
                coins.forEach(coin => drawCoin(coin));
                
                // Draw fireballs
                fireballs.forEach(fireball => drawFireball(fireball));
                
                // Draw bots
                bots.forEach(bot => drawBot(bot));
                
                // Draw other players
                otherPlayers.forEach(otherPlayer => {
                    if (otherPlayer.alive) {
                        drawWizard(otherPlayer, false);
                    }
                });
                
                // Debug: Show other players info
                if (otherPlayers.size > 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(10, 180, 200, 80);
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.fillText(`Other players: ${otherPlayers.size}`, 15, 200);
                    let y = 215;
                    otherPlayers.forEach((player, id) => {
                        ctx.fillText(`${id.substring(0, 8)}: (${Math.round(player.x)}, ${Math.round(player.y)})`, 15, y);
                        y += 15;
                    });
                }
                
                // Debug: Show shared game state
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 270, 200, 60);
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.fillText(`Shared Map State:`, 15, 290);
                ctx.fillText(`Coins: ${coins.filter(c => !c.collected).length}`, 15, 305);
                ctx.fillText(`Bots: ${bots.filter(b => b.alive).length}`, 15, 320);
                ctx.fillText(`Fireballs: ${fireballs.length}`, 15, 335);
                
                // Draw player
                if (player.alive) {
                    drawWizard(player, true);
                }
                
                // Draw UI
                drawUI();
                
                // Draw game over screen if player is dead
                if (!player.alive) {
                    drawGameOver();
                }
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        connectToServer();
        gameLoop();
    </script>
</body>
</html> 